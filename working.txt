package com.example.violenceapp

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.os.IBinder
import android.os.PowerManager
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import com.example.violenceapp.services.AlertService
import java.util.*

class VoiceRecognitionService : Service() {

    companion object {
        private const val TAG = "VoiceRecognitionService"
        private const val NOTIFICATION_ID = 1001
        private const val CHANNEL_ID = "voice_recognition_channel"
        private const val CHANNEL_NAME = "Reconocimiento de Voz + Telegram"
    }

    private var wakeLock: PowerManager.WakeLock? = null
    private var speechRecognizer: SpeechRecognizer? = null
    private var isRunning = false
    private var isListening = false
    private var recognitionCount = 0
    private var alertCount = 0

    // Sistema de alertas por Telegram
    private lateinit var alertService: AlertService

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "üé§ Servicio de reconocimiento de voz creado")
        createNotificationChannel()
        acquireWakeLock()
        setupSpeechRecognizer()

        // Inicializar sistema de alertas por Telegram
        alertService = AlertService(this)
        Log.d(TAG, "üö® Sistema de alertas por Telegram inicializado")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            "START_RECOGNITION" -> startRecognition()
            "STOP_RECOGNITION" -> stopRecognition()
        }
        return START_STICKY
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onDestroy() {
        super.onDestroy()
        cleanup()
    }

    private fun startRecognition() {
        if (!hasAudioPermission()) {
            Log.e(TAG, "‚ùå Sin permisos de audio")
            stopSelf()
            return
        }

        isRunning = true
        val notification = createNotification()
        startForeground(NOTIFICATION_ID, notification)
        startListening()

        Log.i(TAG, "‚úÖ Reconocimiento de voz iniciado - Sistema de alertas por Telegram activo")
    }

    private fun stopRecognition() {
        isRunning = false
        isListening = false
        speechRecognizer?.stopListening()
        stopForeground(true)
        stopSelf()

        Log.i(TAG, "‚èπÔ∏è Reconocimiento de voz detenido - Sistema de alertas desactivado")
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val notificationManager = getSystemService(NotificationManager::class.java)

            val existingChannel = notificationManager.getNotificationChannel(CHANNEL_ID)
            if (existingChannel?.importance == NotificationManager.IMPORTANCE_NONE) {
                notificationManager.deleteNotificationChannel(CHANNEL_ID)
            }

            val channel =
                    NotificationChannel(
                                    CHANNEL_ID,
                                    CHANNEL_NAME,
                                    NotificationManager.IMPORTANCE_DEFAULT
                            )
                            .apply {
                                description = "Reconocimiento de voz con alertas autom√°ticas por Telegram"
                                setShowBadge(true)
                                enableLights(false)
                                enableVibration(false)
                                setSound(null, null)
                                lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                            }

            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createNotification(): Notification {
        val stopIntent =
                Intent(this, VoiceRecognitionService::class.java).apply {
                    action = "STOP_RECOGNITION"
                }
        val stopPendingIntent =
                PendingIntent.getService(
                        this,
                        0,
                        stopIntent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                )

        val statusText = if (alertCount > 0) {
            "üö® Alertas enviadas: $alertCount"
        } else {
            "üé§ Escuchando... | üì± Telegram listo"
        }

        return NotificationCompat.Builder(this, CHANNEL_ID)
                .setContentTitle("üé§ Voz + üì± Telegram")
                .setContentText(statusText)
                .setSmallIcon(android.R.drawable.ic_btn_speak_now)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                .addAction(android.R.drawable.ic_media_pause, "Detener", stopPendingIntent)
                .setStyle(
                        NotificationCompat.BigTextStyle()
                                .bigText(
                                        "üé§ Reconocimiento de voz activo\nüì± Env√≠o autom√°tico por Telegram\nüö® Di 'alerta' para activar emergencia"
                                )
                )
                .build()
    }

    private fun setupSpeechRecognizer() {
        if (!hasAudioPermission()) return

        speechRecognizer = SpeechRecognizer.createSpeechRecognizer(this)
        speechRecognizer?.setRecognitionListener(createRecognitionListener())
    }

    private fun createRecognitionListener() =
            object : RecognitionListener {
                override fun onReadyForSpeech(params: Bundle?) {
                    isListening = true
                    Log.d(TAG, "‚úÖ Listo para escuchar - Sistema de alertas activo")
                }

                override fun onBeginningOfSpeech() {
                    Log.d(TAG, "üé§ Comenzando a hablar...")
                }

                override fun onRmsChanged(rmsdB: Float) {}
                override fun onBufferReceived(buffer: ByteArray?) {}

                override fun onEndOfSpeech() {
                    Log.d(TAG, "üîá Fin del habla")
                }

                override fun onError(error: Int) {
                    val errorMsg = when (error) {
                        SpeechRecognizer.ERROR_AUDIO -> "Error de audio"
                        SpeechRecognizer.ERROR_CLIENT -> "Error del cliente"
                        SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -> "Sin permisos"
                        SpeechRecognizer.ERROR_NETWORK -> "Error de red"
                        SpeechRecognizer.ERROR_NETWORK_TIMEOUT -> "Timeout de red"
                        SpeechRecognizer.ERROR_NO_MATCH -> "Sin coincidencias"
                        SpeechRecognizer.ERROR_RECOGNIZER_BUSY -> "Reconocedor ocupado"
                        SpeechRecognizer.ERROR_SERVER -> "Error del servidor"
                        SpeechRecognizer.ERROR_SPEECH_TIMEOUT -> "Timeout de voz"
                        else -> "Error desconocido: $error"
                    }
                    Log.e(TAG, "‚ùå Error de reconocimiento: $errorMsg")
                    isListening = false
                    scheduleRestart()
                }

                override fun onResults(results: Bundle?) {
                    handleResults(results)
                }

                override fun onPartialResults(partialResults: Bundle?) {
                    handlePartialResults(partialResults)
                }

                override fun onEvent(eventType: Int, params: Bundle?) {}
            }

    private fun handleResults(results: Bundle?) {
        val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
        matches?.firstOrNull()?.let { recognizedText ->
            recognitionCount++
            Log.i(TAG, "üìù Reconocido [$recognitionCount]: $recognizedText")

            // üö® PROCESAR ALERTAS POR TELEGRAM üö®
            processAlert(recognizedText)

            // Enviar broadcast para la UI
            val intent =
                    Intent("VOICE_RECOGNIZED").apply {
                        putExtra("recognized_text", recognizedText)
                        putExtra("recognition_count", recognitionCount)
                    }
            sendBroadcast(intent)
        }

        isListening = false
        scheduleRestart()
    }

    private fun handlePartialResults(partialResults: Bundle?) {
        val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
        matches?.firstOrNull()?.let { partialText ->
            // Procesar texto parcial para alertas m√°s r√°pidas
            if (partialText.contains("alerta", ignoreCase = true) || 
                partialText.contains("auxilio", ignoreCase = true) ||
                partialText.contains("ayuda", ignoreCase = true)) {
                Log.w(TAG, "‚ö° Alerta detectada en texto parcial: $partialText")
                processAlert(partialText)
            }

            val intent = Intent("VOICE_PARTIAL").apply { putExtra("partial_text", partialText) }
            sendBroadcast(intent)
        }
    }

    private fun processAlert(text: String) {
        try {
            // Procesar con el sistema de alertas
            alertService.processRecognizedText(text)
            
            // Si fue una alerta, incrementar contador
            if (text.contains("alerta", ignoreCase = true) || 
                text.contains("auxilio", ignoreCase = true) ||
                text.contains("ayuda", ignoreCase = true)) {
                alertCount++
                updateNotification()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error procesando alerta: ${e.message}")
        }
    }

    private fun updateNotification() {
        val notificationManager = getSystemService(NotificationManager::class.java)
        val updatedNotification = createNotification()
        notificationManager.notify(NOTIFICATION_ID, updatedNotification)
    }

    private fun startListening() {
        if (isListening || !isRunning || !hasAudioPermission()) return

        val intent =
                Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
                    putExtra(
                            RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                            RecognizerIntent.LANGUAGE_MODEL_FREE_FORM
                    )
                    putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())
                    putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
                    putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
                    putExtra(
                            RecognizerIntent.EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS,
                            3000
                    )
                    putExtra(
                            RecognizerIntent.EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS,
                            3000
                    )
                }

        try {
            speechRecognizer?.startListening(intent)
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error iniciando reconocimiento", e)
            scheduleRestart()
        }
    }

    private fun scheduleRestart() {
        if (!isRunning) return

        android.os.Handler(android.os.Looper.getMainLooper())
                .postDelayed(
                        {
                            if (isRunning && !isListening) {
                                startListening()
                            }
                        },
                        1000L
                )
    }

    private fun hasAudioPermission(): Boolean {
        return ContextCompat.checkSelfPermission(this, android.Manifest.permission.RECORD_AUDIO) ==
                PackageManager.PERMISSION_GRANTED
    }

    private fun acquireWakeLock() {
        val powerManager = getSystemService(POWER_SERVICE) as PowerManager
        wakeLock =
                powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "$TAG::WakeLock").apply {
                    acquire(60 * 60 * 1000L)
                }
    }

    private fun cleanup() {
        isRunning = false
        speechRecognizer?.destroy()
        wakeLock?.let { if (it.isHeld) it.release() }
        Log.d(TAG, "üßπ Limpieza del servicio completada")
    }
}

package com.example.violenceapp.data

/**
 * Configuraci√≥n de alertas para Telegram
 * Simplificada para usar solo Telegram como canal de comunicaci√≥n
 */
data class AlertConfiguration(
        // Palabra clave que activa la alerta
        val triggerWord: String = "alerta",
        
        // Plantilla del mensaje de emergencia
        val messageTemplate: String = """
üö® <b>ALERTA DE EMERGENCIA</b> üö®

¬°NECESITO AYUDA URGENTE!

üìç <b>Ubicaci√≥n:</b> {location}
üïê <b>Hora:</b> {time}
üîä <b>Activado por:</b> "{trigger}"

‚ö†Ô∏è <i>Por favor contacta a las autoridades si no respondo en 15 minutos.</i>

ü§ñ <i>Este mensaje fue enviado autom√°ticamente por el sistema de reconocimiento de voz.</i>
        """.trimIndent(),
        
        // Estado del sistema de alertas
        val isEnabled: Boolean = true,
        
        // Configuraciones adicionales para Telegram
        val sendLocation: Boolean = true,          // Enviar ubicaci√≥n en tiempo real
        val locationLivePeriod: Int = 300,         // 5 minutos de ubicaci√≥n en vivo
        val retryAttempts: Int = 3,                // Intentos de reenv√≠o en caso de fallo
        val retryDelaySeconds: Int = 5             // Delay entre intentos
) {
    /**
     * Valida que la configuraci√≥n sea correcta
     */
    fun isValid(): Boolean {
        return triggerWord.isNotBlank() && 
               messageTemplate.isNotBlank() &&
               messageTemplate.contains("{location}") &&
               messageTemplate.contains("{time}") &&
               messageTemplate.contains("{trigger}")
    }

    /**
     * Obtiene las palabras clave alternativas (variaciones de la palabra principal)
     */
    fun getTriggerVariations(): List<String> {
        return listOf(
            triggerWord.lowercase(),
            triggerWord.uppercase(),
            "auxilio",
            "ayuda",
            "socorro",
            "emergencia",
            "help"
        )
    }

    /**
     * Verifica si un texto contiene alguna palabra clave
     */
    fun containsTrigger(text: String): Boolean {
        val normalizedText = text.lowercase()
        return getTriggerVariations().any { trigger ->
            normalizedText.contains(trigger.lowercase())
        }
    }

    /**
     * Formatea el mensaje reemplazando las variables
     */
    fun formatMessage(location: String, time: String, trigger: String): String {
        return messageTemplate
            .replace("{location}", location)
            .replace("{time}", time)
            .replace("{trigger}", trigger)
    }

    companion object {
        /**
         * Configuraci√≥n por defecto para pruebas
         */
        fun createTestConfiguration(): AlertConfiguration {
            return AlertConfiguration(
                triggerWord = "prueba",
                messageTemplate = """
üß™ <b>MENSAJE DE PRUEBA</b>

üìç <b>Ubicaci√≥n:</b> {location}
üïê <b>Hora:</b> {time}
üîä <b>Activado por:</b> "{trigger}"

‚úÖ <i>Tu sistema de alertas de emergencia est√° funcionando correctamente.</i>
                """.trimIndent(),
                isEnabled = true
            )
        }

        /**
         * Configuraci√≥n m√≠nima para casos de emergencia real
         */
        fun createMinimalConfiguration(): AlertConfiguration {
            return AlertConfiguration(
                triggerWord = "alerta",
                messageTemplate = """
üö® EMERGENCIA üö®

Ubicaci√≥n: {location}
Hora: {time}
Detectado: "{trigger}"

Contactar autoridades si no hay respuesta.
                """.trimIndent(),
                isEnabled = true
            )
        }
    }
}

package com.example.violenceapp.services

import android.content.Context
import android.util.Log
import com.example.violenceapp.data.AlertConfiguration
import com.example.violenceapp.utils.LocationHelper
import com.example.violenceapp.utils.TelegramHelper
import java.text.SimpleDateFormat
import java.util.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class AlertService(private val context: Context) {

    companion object {
        private const val TAG = "AlertService"
    }

    private val locationHelper = LocationHelper(context)
    private val telegramHelper = TelegramHelper(context)
    private val alertConfig = AlertConfiguration()

    private val coroutineScope = CoroutineScope(Dispatchers.IO)

    /**
     * Procesa texto reconocido y activa alerta si detecta palabra clave
     */
    fun processRecognizedText(text: String) {
        if (!alertConfig.isEnabled) {
            Log.d(TAG, "Alertas deshabilitadas")
            return
        }

        // Verificar si el texto contiene la palabra clave (case insensitive)
        if (text.contains(alertConfig.triggerWord, ignoreCase = true)) {
            Log.w(TAG, "üö® PALABRA CLAVE DETECTADA: '$text'")
            triggerEmergencyAlert(text)
        }
    }

    /**
     * Activa alerta de emergencia completa
     */
    private fun triggerEmergencyAlert(triggeredText: String) {
        Log.w(TAG, "üö® ACTIVANDO ALERTA DE EMERGENCIA üö®")

        coroutineScope.launch {
            try {
                // Obtener ubicaci√≥n actual
                val locationString = locationHelper.getCurrentLocation() ?: "Ubicaci√≥n no disponible"

                // Obtener tiempo actual
                val currentTime = SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault()).format(Date())

                // Preparar mensaje usando la plantilla
                val emergencyMessage = alertConfig
                        .messageTemplate
                        .replace("{location}", locationString)
                        .replace("{time}", currentTime)
                        .replace("{trigger}", triggeredText)

                Log.i(TAG, "Mensaje de emergencia preparado")

                // üö® ENV√çO AUTOM√ÅTICO POR TELEGRAM üö®
                val messageSent = telegramHelper.sendAutomaticMessage(emergencyMessage)

                if (messageSent) {
                    Log.i(TAG, "‚úÖ ALERTA ENVIADA EXITOSAMENTE POR TELEGRAM")
                    
                    // Intentar enviar ubicaci√≥n en tiempo real si est√° disponible
                    sendLiveLocationIfAvailable()
                    
                    // Mostrar notificaci√≥n de √©xito
                    launch(Dispatchers.Main) { 
                        showAlertSentNotification(emergencyMessage)
                    }
                } else {
                    Log.e(TAG, "‚ùå FALLO AL ENVIAR ALERTA POR TELEGRAM")
                    
                    // Mostrar notificaci√≥n de error
                    launch(Dispatchers.Main) { 
                        showAlertFailedNotification("Error de conexi√≥n o configuraci√≥n")
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error procesando alerta de emergencia: ${e.message}")
                launch(Dispatchers.Main) { 
                    showAlertFailedNotification("Error interno: ${e.message}")
                }
            }
        }
    }

    /**
     * Env√≠a ubicaci√≥n en tiempo real si est√° disponible
     */
    private suspend fun sendLiveLocationIfAvailable() {
        try {
            if (!locationHelper.hasLocationPermission()) {
                Log.w(TAG, "Sin permisos de ubicaci√≥n para env√≠o en tiempo real")
                return
            }

            // Intentar obtener coordenadas precisas para ubicaci√≥n en vivo
            val locationString = locationHelper.getCurrentLocation()
            
            if (locationString != null && locationString.contains("Lat:")) {
                // Extraer coordenadas del string de ubicaci√≥n
                val latRegex = Regex("Lat: ([+-]?\\d*\\.?\\d+)")
                val lonRegex = Regex("Lon: ([+-]?\\d*\\.?\\d+)")
                
                val latMatch = latRegex.find(locationString)
                val lonMatch = lonRegex.find(locationString)
                
                if (latMatch != null && lonMatch != null) {
                    val latitude = latMatch.groupValues[1].toDouble()
                    val longitude = lonMatch.groupValues[1].toDouble()
                    
                    val locationSent = telegramHelper.sendLocationMessage(
                        latitude, 
                        longitude, 
                        "üìç Ubicaci√≥n en tiempo real - Emergencia activa"
                    )
                    
                    if (locationSent) {
                        Log.i(TAG, "‚úÖ Ubicaci√≥n en tiempo real enviada")
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error enviando ubicaci√≥n en tiempo real: ${e.message}")
        }
    }

    /**
     * Muestra notificaci√≥n de alerta enviada exitosamente
     */
    private fun showAlertSentNotification(message: String) {
        try {
            val notificationManager =
                    context.getSystemService(Context.NOTIFICATION_SERVICE) as
                            android.app.NotificationManager

            // Crear canal para alertas cr√≠ticas
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                val channel =
                        android.app.NotificationChannel(
                                        "emergency_alerts",
                                        "Alertas de Emergencia",
                                        android.app.NotificationManager.IMPORTANCE_HIGH
                                )
                                .apply {
                                    description = "Notificaciones de alertas de emergencia enviadas por Telegram"
                                    enableLights(true)
                                    lightColor = android.graphics.Color.GREEN
                                    enableVibration(true)
                                    vibrationPattern = longArrayOf(0, 300, 200, 300, 200, 300)
                                }
                notificationManager.createNotificationChannel(channel)
            }

            val notification =
                    androidx.core.app.NotificationCompat.Builder(context, "emergency_alerts")
                            .setContentTitle("‚úÖ Alerta Enviada por Telegram")
                            .setContentText("Tu mensaje de emergencia fue enviado autom√°ticamente")
                            .setSmallIcon(android.R.drawable.ic_dialog_info)
                            .setPriority(androidx.core.app.NotificationCompat.PRIORITY_HIGH)
                            .setCategory(androidx.core.app.NotificationCompat.CATEGORY_ALARM)
                            .setVibrate(longArrayOf(0, 300, 200, 300))
                            .setAutoCancel(true)
                            .setStyle(
                                    androidx.core.app.NotificationCompat.BigTextStyle()
                                            .bigText("‚úÖ Alerta enviada exitosamente por Telegram:\n\n${message.take(100)}...")
                            )
                            .build()

            notificationManager.notify(9999, notification)
        } catch (e: Exception) {
            Log.e(TAG, "Error mostrando notificaci√≥n de √©xito: ${e.message}")
        }
    }

    /**
     * Muestra notificaci√≥n de error al enviar alerta
     */
    private fun showAlertFailedNotification(errorDetails: String) {
        try {
            val notificationManager =
                    context.getSystemService(Context.NOTIFICATION_SERVICE) as
                            android.app.NotificationManager

            val notification =
                    androidx.core.app.NotificationCompat.Builder(context, "emergency_alerts")
                            .setContentTitle("‚ùå Error Enviando Alerta")
                            .setContentText("No se pudo enviar el mensaje por Telegram")
                            .setSmallIcon(android.R.drawable.ic_dialog_alert)
                            .setPriority(androidx.core.app.NotificationCompat.PRIORITY_HIGH)
                            .setCategory(androidx.core.app.NotificationCompat.CATEGORY_ERROR)
                            .setAutoCancel(true)
                            .setStyle(
                                    androidx.core.app.NotificationCompat.BigTextStyle()
                                            .bigText("‚ùå Error: $errorDetails\n\nVerifica tu conexi√≥n y configuraci√≥n de Telegram")
                            )
                            .build()

            notificationManager.notify(9998, notification)
        } catch (e: Exception) {
            Log.e(TAG, "Error mostrando notificaci√≥n de error: ${e.message}")
        }
    }

    /**
     * Valida la configuraci√≥n de Telegram
     */
    suspend fun validateTelegramConfiguration(): Boolean {
        return try {
            telegramHelper.validateBotConfiguration()
        } catch (e: Exception) {
            Log.e(TAG, "Error validando configuraci√≥n de Telegram: ${e.message}")
            false
        }
    }

    /**
     * Env√≠a mensaje de prueba
     */
    suspend fun sendTestAlert(): Boolean {
        return try {
            telegramHelper.sendTestMessage()
        } catch (e: Exception) {
            Log.e(TAG, "Error enviando mensaje de prueba: ${e.message}")
            false
        }
    }

    /**
     * Obtiene informaci√≥n del bot configurado
     */
    suspend fun getBotInfo(): String? {
        return try {
            telegramHelper.getBotInfo()
        } catch (e: Exception) {
            Log.e(TAG, "Error obteniendo informaci√≥n del bot: ${e.message}")
            null
        }
    }

    // M√©todos de configuraci√≥n para futuras actualizaciones
    fun updateTriggerWord(newTriggerWord: String) {
        Log.d(TAG, "Palabra clave ser√≠a actualizada a: $newTriggerWord")
        // TODO: Implementar cuando tengamos configuraci√≥n persistente
    }

    fun updateMessageTemplate(newTemplate: String) {
        Log.d(TAG, "Plantilla de mensaje ser√≠a actualizada")
        // TODO: Implementar cuando tengamos configuraci√≥n persistente
    }

    fun isConfigurationValid(): Boolean {
        return alertConfig.triggerWord.isNotBlank() &&
                alertConfig.messageTemplate.isNotBlank()
    }

    /**
     * Habilita o deshabilita el sistema de alertas
     */
    fun setAlertsEnabled(enabled: Boolean) {
        // TODO: Implementar configuraci√≥n persistente
        Log.d(TAG, "Alertas ${if (enabled) "habilitadas" else "deshabilitadas"}")
    }
}

package com.example.violenceapp

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.ContextCompat
import com.example.violenceapp.ui.theme.ViolenceAppTheme
import com.example.violenceapp.services.AlertService
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class MainActivity : ComponentActivity() {

    private var isServiceRunning by mutableStateOf(false)
    private var statusText by mutableStateOf("Estado: Inactivo")
    private var recognizedTexts by mutableStateOf(listOf<String>())
    private var partialText by mutableStateOf("")
    private var recognitionCount by mutableStateOf(0)
    private var isTelegramConfigured by mutableStateOf(false)
    private var telegramStatus by mutableStateOf("Verificando configuraci√≥n...")

    // Instancia del AlertService para validar configuraci√≥n
    private lateinit var alertService: AlertService

    private val voiceReceiver =
            object : BroadcastReceiver() {
                override fun onReceive(context: Context?, intent: Intent?) {
                    when (intent?.action) {
                        "VOICE_RECOGNIZED" -> {
                            val recognizedText = intent.getStringExtra("recognized_text") ?: ""
                            val count = intent.getIntExtra("recognition_count", 0)
                            recognizedTexts = recognizedTexts + recognizedText
                            recognitionCount = count
                            partialText = ""
                        }
                        "VOICE_PARTIAL" -> {
                            val partial = intent.getStringExtra("partial_text") ?: ""
                            partialText = partial
                        }
                    }
                }
            }

    private val requestPermissionLauncher =
            registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) {
                    permissions ->
                val allGranted = permissions.values.all { it }
                if (allGranted) {
                    Toast.makeText(this, "Permisos concedidos", Toast.LENGTH_SHORT).show()
                    // Verificar configuraci√≥n de Telegram despu√©s de obtener permisos
                    validateTelegramConfiguration()
                } else {
                    Toast.makeText(this, "Permisos necesarios para el funcionamiento", Toast.LENGTH_LONG).show()
                }
            }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Inicializar AlertService
        alertService = AlertService(this)

        checkPermissions()
        registerVoiceReceiver()
        validateTelegramConfiguration()

        setContent {
            ViolenceAppTheme {
                Surface(
                        modifier = Modifier.fillMaxSize(),
                        color = MaterialTheme.colorScheme.background
                ) { VoiceRecognitionScreen() }
            }
        }
    }

    @Composable
    fun VoiceRecognitionScreen() {
        Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
            // Header con estado del servicio
            Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Center,
                    verticalAlignment = Alignment.CenterVertically
            ) {
                Card(
                        modifier = Modifier.size(60.dp),
                        shape = RoundedCornerShape(30.dp),
                        colors =
                                CardDefaults.cardColors(
                                        containerColor =
                                                if (isServiceRunning)
                                                        MaterialTheme.colorScheme.primary
                                                else MaterialTheme.colorScheme.surfaceVariant
                                )
                ) {
                    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        Text(text = if (isServiceRunning) "üé§" else "üîá", fontSize = 24.sp)
                    }
                }

                Spacer(modifier = Modifier.width(16.dp))

                Column {
                    Text(
                            text = "Reconocimiento de Voz",
                            fontSize = 20.sp,
                            fontWeight = FontWeight.Bold
                    )
                    Text(
                            text =
                                    if (recognitionCount > 0) "Textos: $recognitionCount"
                                    else statusText,
                            fontSize = 14.sp,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Estado de Telegram
            Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                            containerColor = if (isTelegramConfigured) 
                                MaterialTheme.colorScheme.primaryContainer
                            else MaterialTheme.colorScheme.errorContainer
                    )
            ) {
                Row(
                        modifier = Modifier.fillMaxWidth().padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                            text = if (isTelegramConfigured) "‚úÖ" else "‚ùå",
                            fontSize = 20.sp
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Column {
                        Text(
                                text = "Telegram Bot",
                                fontSize = 16.sp,
                                fontWeight = FontWeight.Medium
                        )
                        Text(
                                text = telegramStatus,
                                fontSize = 14.sp,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        if (isServiceRunning && isTelegramConfigured) {
                            Text(
                                    text = "üö® Env√≠o autom√°tico activo: Di 'alerta'",
                                    fontSize = 12.sp,
                                    color = MaterialTheme.colorScheme.error,
                                    fontWeight = FontWeight.Medium
                            )
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Botones
            Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                        onClick = { startVoiceService() },
                        enabled = !isServiceRunning && isTelegramConfigured,
                        modifier = Modifier.weight(1f)
                ) { 
                    Text(if (!isTelegramConfigured) "‚ö†Ô∏è Config Bot" else "‚ñ∂Ô∏è Iniciar")
                }

                OutlinedButton(
                        onClick = { stopVoiceService() },
                        enabled = isServiceRunning,
                        modifier = Modifier.weight(1f)
                ) { Text("‚è∏Ô∏è Detener") }

                OutlinedButton(
                        onClick = { validateTelegramConfiguration() },
                        modifier = Modifier.weight(1f)
                ) { Text("üîÑ Verificar") }
            }

            if (recognizedTexts.isNotEmpty()) {
                Row(
                        modifier = Modifier.fillMaxWidth().padding(top = 8.dp),
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    OutlinedButton(
                            onClick = {
                                recognizedTexts = listOf()
                                recognitionCount = 0
                            },
                            modifier = Modifier.weight(1f)
                    ) { Text("üóëÔ∏è Limpiar") }

                    OutlinedButton(
                            onClick = { testTelegramMessage() },
                            enabled = isTelegramConfigured,
                            modifier = Modifier.weight(1f)
                    ) { Text("üì§ Test Telegram") }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Texto parcial
            if (partialText.isNotEmpty()) {
                Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors =
                                CardDefaults.cardColors(
                                        containerColor =
                                                MaterialTheme.colorScheme.secondaryContainer
                                )
                ) {
                    Text(
                            text = "üîÑ $partialText",
                            modifier = Modifier.padding(16.dp),
                            fontSize = 16.sp
                    )
                }
                Spacer(modifier = Modifier.height(8.dp))
            }

            // Lista de textos reconocidos
            if (recognizedTexts.isNotEmpty()) {
                Text(
                        text = "Textos Reconocidos:",
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Medium,
                        modifier = Modifier.padding(vertical = 8.dp)
                )

                LazyColumn(
                        modifier = Modifier.fillMaxWidth(),
                        verticalArrangement = Arrangement.spacedBy(8.dp),
                        reverseLayout = true
                ) {
                    itemsIndexed(recognizedTexts.reversed()) { index, text ->
                        Card(
                                modifier = Modifier.fillMaxWidth(),
                                colors =
                                        CardDefaults.cardColors(
                                                containerColor = if (text.contains("alerta", ignoreCase = true))
                                                        MaterialTheme.colorScheme.errorContainer
                                                else MaterialTheme.colorScheme.primaryContainer
                                        )
                        ) {
                            Column(modifier = Modifier.padding(16.dp)) {
                                Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                ) {
                                    Text(
                                            text = "#${recognizedTexts.size - index}",
                                            fontSize = 12.sp,
                                            color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                                    )
                                    if (text.contains("alerta", ignoreCase = true)) {
                                        Text(
                                                text = "üö® ALERTA",
                                                fontSize = 12.sp,
                                                fontWeight = FontWeight.Bold,
                                                color = MaterialTheme.colorScheme.error
                                        )
                                    }
                                }
                                Text(
                                        text = text,
                                        fontSize = 16.sp,
                                        color = MaterialTheme.colorScheme.onPrimaryContainer
                                )
                            }
                        }
                    }
                }
            } else if (isServiceRunning) {
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                                text = "üé§ Esperando que hables...",
                                fontSize = 16.sp,
                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                textAlign = TextAlign.Center
                        )
                        if (isTelegramConfigured) {
                            Text(
                                    text = "Di 'alerta' para enviar mensaje autom√°tico",
                                    fontSize = 14.sp,
                                    color = MaterialTheme.colorScheme.primary,
                                    textAlign = TextAlign.Center
                            )
                        }
                    }
                }
            } else {
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                                text = if (isTelegramConfigured) 
                                    "Presiona 'Iniciar' para comenzar\nel reconocimiento de voz"
                                else "Configura el bot de Telegram\nprimero para continuar",
                                fontSize = 16.sp,
                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                textAlign = TextAlign.Center
                        )
                    }
                }
            }
        }
    }

    private fun checkPermissions() {
        val permissions = mutableListOf<String>()

        if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) !=
                        PackageManager.PERMISSION_GRANTED
        ) {
            permissions.add(Manifest.permission.RECORD_AUDIO)
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=
                            PackageManager.PERMISSION_GRANTED
            ) {
                permissions.add(Manifest.permission.POST_NOTIFICATIONS)
            }
        }

        // Permisos para ubicaci√≥n
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) !=
                        PackageManager.PERMISSION_GRANTED
        ) {
            permissions.add(Manifest.permission.ACCESS_FINE_LOCATION)
        }

        // Permisos para internet (Telegram)
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.INTERNET) !=
                        PackageManager.PERMISSION_GRANTED
        ) {
            permissions.add(Manifest.permission.INTERNET)
        }

        if (permissions.isNotEmpty()) {
            requestPermissionLauncher.launch(permissions.toTypedArray())
        }
    }

    private fun validateTelegramConfiguration() {
        telegramStatus = "Verificando..."
        isTelegramConfigured = false

        CoroutineScope(Dispatchers.Main).launch {
            try {
                val isValid = alertService.validateTelegramConfiguration()
                
                if (isValid) {
                    telegramStatus = "Bot configurado correctamente"
                    isTelegramConfigured = true
                    Toast.makeText(this@MainActivity, "‚úÖ Telegram configurado", Toast.LENGTH_SHORT).show()
                } else {
                    telegramStatus = "Error: Revisa BOT_TOKEN y CHAT_ID"
                    isTelegramConfigured = false
                    Toast.makeText(this@MainActivity, "‚ùå Error en configuraci√≥n de Telegram", Toast.LENGTH_LONG).show()
                }
            } catch (e: Exception) {
                telegramStatus = "Error de conexi√≥n: ${e.message}"
                isTelegramConfigured = false
                Toast.makeText(this@MainActivity, "‚ùå Error: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun testTelegramMessage() {
        if (!isTelegramConfigured) {
            Toast.makeText(this, "Configura Telegram primero", Toast.LENGTH_SHORT).show()
            return
        }

        CoroutineScope(Dispatchers.Main).launch {
            try {
                // Simular una alerta de prueba
                alertService.processRecognizedText("alerta de prueba")
                Toast.makeText(this@MainActivity, "üì§ Mensaje de prueba enviado", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Toast.makeText(this@MainActivity, "‚ùå Error enviando prueba: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun registerVoiceReceiver() {
        val filter =
                IntentFilter().apply {
                    addAction("VOICE_RECOGNIZED")
                    addAction("VOICE_PARTIAL")
                }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(voiceReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(voiceReceiver, filter)
        }
    }

    private fun startVoiceService() {
        if (!isTelegramConfigured) {
            Toast.makeText(this, "Configura Telegram antes de iniciar", Toast.LENGTH_LONG).show()
            return
        }

        try {
            val intent =
                    Intent(this, VoiceRecognitionService::class.java).apply {
                        action = "START_RECOGNITION"
                    }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                startForegroundService(intent)
            } else {
                startService(intent)
            }

            isServiceRunning = true
            statusText = "Estado: Servicio iniciado con Telegram"
        } catch (e: Exception) {
            Toast.makeText(this, "Error: ${e.message}", Toast.LENGTH_LONG).show()
        }
    }

    private fun stopVoiceService() {
        try {
            val intent =
                    Intent(this, VoiceRecognitionService::class.java).apply {
                        action = "STOP_RECOGNITION"
                    }
            startService(intent)

            isServiceRunning = false
            statusText = "Estado: Servicio detenido"
            recognizedTexts = listOf()
            partialText = ""
            recognitionCount = 0
        } catch (e: Exception) {
            Toast.makeText(this, "Error: ${e.message}", Toast.LENGTH_LONG).show()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            unregisterReceiver(voiceReceiver)
        } catch (e: Exception) {
            // Receiver ya no registrado
        }
    }
}
package com.example.violenceapp.utils

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.OutputStreamWriter
import java.net.HttpURLConnection
import java.net.URL
import java.net.URLEncoder
import org.json.JSONObject

class TelegramHelper(private val context: Context) {

    companion object {
        private const val TAG = "TelegramHelper"
        
        // üö® CONFIGURACI√ìN DEL BOT - REEMPLAZAR CON TUS DATOS REALES
        private const val BOT_TOKEN = "8397338322:AAGlGZM3p2ZPVjrT68l5RTD8KZvk9vEjS3o"
        private const val CHAT_ID = "TU_CHAT_ID_AQUI" // Cambiar por tu chat ID num√©rico
        
        private const val TELEGRAM_API_URL = "https://api.telegram.org/bot"
    }

    /**
     * Env√≠a mensaje autom√°ticamente por Telegram
     * ‚úÖ Completamente autom√°tico sin intervenci√≥n del usuario
     * ‚úÖ Funciona en background
     */
    suspend fun sendAutomaticMessage(message: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                if (BOT_TOKEN.isEmpty() || CHAT_ID == "TU_CHAT_ID_AQUI") {
                    Log.e(TAG, "‚ùå Bot token o chat ID no configurados")
                    return@withContext false
                }

                val url = URL("$TELEGRAM_API_URL$BOT_TOKEN/sendMessage")
                val connection = url.openConnection() as HttpURLConnection

                connection.apply {
                    requestMethod = "POST"
                    setRequestProperty("Content-Type", "application/x-www-form-urlencoded")
                    setRequestProperty("User-Agent", "EmergencyApp/1.0")
                    doOutput = true
                    connectTimeout = 15000 // 15 segundos
                    readTimeout = 20000    // 20 segundos
                }

                // Formatear mensaje con HTML
                val formattedMessage = formatEmergencyMessage(message)
                
                // Preparar datos para env√≠o
                val postData = "chat_id=${URLEncoder.encode(CHAT_ID, "UTF-8")}" +
                        "&text=${URLEncoder.encode(formattedMessage, "UTF-8")}" +
                        "&parse_mode=HTML" +
                        "&disable_web_page_preview=false"

                // Enviar request
                OutputStreamWriter(connection.outputStream).use { writer ->
                    writer.write(postData)
                    writer.flush()
                }

                // Procesar respuesta
                val responseCode = connection.responseCode
                
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().use { it.readText() }
                    val jsonResponse = JSONObject(response)
                    
                    if (jsonResponse.getBoolean("ok")) {
                        Log.i(TAG, "‚úÖ MENSAJE DE EMERGENCIA ENVIADO POR TELEGRAM")
                        return@withContext true
                    } else {
                        val errorDesc = jsonResponse.optString("description", "Error desconocido")
                        Log.e(TAG, "‚ùå Error en respuesta de Telegram: $errorDesc")
                        return@withContext false
                    }
                } else {
                    val errorResponse = connection.errorStream?.bufferedReader()?.use { it.readText() }
                    Log.e(TAG, "‚ùå Error HTTP $responseCode: $errorResponse")
                    return@withContext false
                }

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error enviando mensaje por Telegram: ${e.message}")
                return@withContext false
            }
        }
    }

    /**
     * Env√≠a ubicaci√≥n en tiempo real por Telegram
     */
    suspend fun sendLocationMessage(latitude: Double, longitude: Double, caption: String = ""): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                if (BOT_TOKEN.isEmpty() || CHAT_ID == "TU_CHAT_ID_AQUI") {
                    Log.e(TAG, "‚ùå Bot token o chat ID no configurados")
                    return@withContext false
                }

                val url = URL("$TELEGRAM_API_URL$BOT_TOKEN/sendLocation")
                val connection = url.openConnection() as HttpURLConnection

                connection.apply {
                    requestMethod = "POST"
                    setRequestProperty("Content-Type", "application/x-www-form-urlencoded")
                    doOutput = true
                    connectTimeout = 15000
                    readTimeout = 20000
                }

                val postData = "chat_id=${URLEncoder.encode(CHAT_ID, "UTF-8")}" +
                        "&latitude=$latitude" +
                        "&longitude=$longitude" +
                        "&live_period=300" + // Ubicaci√≥n en vivo por 5 minutos
                        if (caption.isNotEmpty()) "&caption=${URLEncoder.encode(caption, "UTF-8")}" else ""

                OutputStreamWriter(connection.outputStream).use { writer ->
                    writer.write(postData)
                    writer.flush()
                }

                val responseCode = connection.responseCode
                
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    Log.i(TAG, "‚úÖ UBICACI√ìN ENVIADA POR TELEGRAM")
                    return@withContext true
                } else {
                    Log.e(TAG, "‚ùå Error enviando ubicaci√≥n: HTTP $responseCode")
                    return@withContext false
                }

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error enviando ubicaci√≥n por Telegram: ${e.message}")
                return@withContext false
            }
        }
    }

    /**
     * Valida la configuraci√≥n del bot
     */
    suspend fun validateBotConfiguration(): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                if (BOT_TOKEN.isEmpty() || BOT_TOKEN == "TU_BOT_TOKEN_AQUI") {
                    Log.e(TAG, "‚ùå Bot token no configurado")
                    return@withContext false
                }

                if (CHAT_ID.isEmpty() || CHAT_ID == "TU_CHAT_ID_AQUI") {
                    Log.e(TAG, "‚ùå Chat ID no configurado")
                    return@withContext false
                }

                val url = URL("$TELEGRAM_API_URL$BOT_TOKEN/getMe")
                val connection = url.openConnection() as HttpURLConnection
                
                connection.apply {
                    requestMethod = "GET"
                    connectTimeout = 10000
                    readTimeout = 10000
                }

                val responseCode = connection.responseCode
                
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().use { it.readText() }
                    val jsonResponse = JSONObject(response)
                    
                    if (jsonResponse.getBoolean("ok")) {
                        val botInfo = jsonResponse.getJSONObject("result")
                        val botName = botInfo.getString("username")
                        val botFirstName = botInfo.getString("first_name")
                        Log.i(TAG, "‚úÖ Bot configurado: $botFirstName (@$botName)")
                        return@withContext true
                    }
                }
                
                Log.e(TAG, "‚ùå Bot token inv√°lido o bot inactivo")
                return@withContext false

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error validando bot: ${e.message}")
                return@withContext false
            }
        }
    }

    /**
     * Env√≠a mensaje de prueba
     */
    suspend fun sendTestMessage(): Boolean {
        val testMessage = """
üß™ <b>MENSAJE DE PRUEBA</b>

‚úÖ Tu bot de Telegram est√° funcionando correctamente
üïê Hora: ${java.text.SimpleDateFormat("dd/MM/yyyy HH:mm:ss", java.util.Locale.getDefault()).format(java.util.Date())}
üö® Listo para enviar alertas de emergencia autom√°ticamente

<i>Este es un mensaje de prueba del sistema de alertas</i>
        """.trimIndent()
        
        return sendAutomaticMessage(testMessage)
    }

    /**
     * Formatea el mensaje de emergencia con HTML
     */
    private fun formatEmergencyMessage(message: String): String {
        return """
üö® <b>ALERTA DE EMERGENCIA</b> üö®

$message

‚ö†Ô∏è <i>Este mensaje fue enviado autom√°ticamente por el sistema de reconocimiento de voz</i>
        """.trimIndent()
    }

    /**
     * Obtiene informaci√≥n del bot configurado
     */
    suspend fun getBotInfo(): String? {
        return withContext(Dispatchers.IO) {
            try {
                if (BOT_TOKEN.isEmpty() || BOT_TOKEN == "TU_BOT_TOKEN_AQUI") {
                    return@withContext null
                }

                val url = URL("$TELEGRAM_API_URL$BOT_TOKEN/getMe")
                val connection = url.openConnection() as HttpURLConnection
                
                connection.apply {
                    requestMethod = "GET"
                    connectTimeout = 5000
                    readTimeout = 5000
                }

                val responseCode = connection.responseCode
                
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().use { it.readText() }
                    val jsonResponse = JSONObject(response)
                    
                    if (jsonResponse.getBoolean("ok")) {
                        val botInfo = jsonResponse.getJSONObject("result")
                        val botName = botInfo.getString("username")
                        val botFirstName = botInfo.getString("first_name")
                        return@withContext "$botFirstName (@$botName)"
                    }
                }
                
                return@withContext null

            } catch (e: Exception) {
                Log.e(TAG, "Error obteniendo info del bot: ${e.message}")
                return@withContext null
            }
        }
    }
}

